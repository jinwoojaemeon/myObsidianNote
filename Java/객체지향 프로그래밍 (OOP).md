8# 객체지향 프로그래밍 (OOP)

#java #oop #객체지향 #설계 #면접 #개념정리

**관련 개념:** [[클래스]] [[객체]] [[상속]] [[다형성]] [[캡슐화]] [[추상화]]

> [!note] 이어서 읽기
> 객체지향 프로그래밍을 이해하려면 **[[클래스]]**와 **[[객체]]**의 차이를 함께 확인하세요.

---

## Topic (오늘의 주제)

**객체지향 프로그래밍(OOP)** 이 무엇인지, 왜 필요한지, 그리고 어떻게 설계하는지 개념적으로 이해한다.

---

### **Why (왜 사용하는가? 왜 중요한가?)**

- 절차지향 프로그래밍으로는 대규모 프로젝트에서 코드 유지보수가 어렵고, 변경 사항이 발생하면 관련된 모든 코드를 수정해야 합니다. 객체지향 프로그래밍을 사용하지 않으면 코드의 재사용성이 떨어지고, 시스템의 복잡도가 증가하여 버그 발생 가능성이 높아집니다. 또한 팀 프로젝트에서 코드 공유와 협업이 어려워집니다.

- 객체지향 프로그래밍은 현실 세계를 추상화하여 사람이 직관적으로 이해하기 쉽고 변경을 용이하게 만드는 개발 방법론입니다. 코드를 객체 단위로 모듈화하여 재사용성을 높이고, 캡슐화를 통해 데이터와 메서드를 함께 관리하여 안정성을 확보합니다. 다형성과 상속을 통해 유연한 설계가 가능하며, 시스템의 확장성과 유지보수성을 크게 향상시킵니다.

- 객체지향의 핵심 개념(캡슐화, 상속, 다형성, 추상화)을 이해하고 있는지, 객체 간의 관계와 책임 분리를 설계할 수 있는지, 데이터 중심 설계와 책임 주도 설계의 차이를 알고 있는지 확인하려 합니다. 또한 실무에서 객체지향 원칙을 적용하여 코드를 작성할 수 있는 능력을 기를 수 있습니다.

---

### **Core Concept (핵심 개념 정리)**

#### 1. 도입: 객체지향 프로그래밍의 정의와 이해

**객체지향 프로그래밍(Object-Oriented Programming, OOP)**은 현실 세계를 추상화하여, 사람이 직관적으로 이해하기 쉽고 변경을 용이하게 만드는 개발 방법론입니다.

**절차지향 프로그래밍과의 차이**:
- **절차지향**: 데이터와 함수가 분리되어 있고, 순차적인 실행 흐름에 집중
- **객체지향**: 데이터와 함수를 객체로 묶어 관리하고, 객체 간의 상호작용에 집중

**비유**: 소설이 현실을 기반으로 쓰이듯, 객체지향 코드도 현실의 개념(야구팀, 투수, 타자 등)을 기반으로 작성되므로 이해하기 쉽습니다.

**객체(Object)**: 현실 세계의 개념을 소프트웨어적으로 추상화한 대상입니다.

**OOP의 목표**:
1. 코드의 재사용성 향상
2. 유지보수성 향상
3. 확장성 향상
4. 코드의 가독성 향상

> [!tip] 핵심 포인트
> 객체지향 프로그래밍은 현실 세계의 개념을 코드로 표현하여 직관적으로 이해할 수 있게 합니다. 이를 통해 복잡한 시스템을 더 쉽게 설계하고 관리할 수 있습니다.

#### 2. 핵심 키워드로 이해하는 객체지향

객체지향을 이해하기 위해 다음의 핵심 키워드들을 '야구 경기 시스템'에 빗대어 설명합니다.

##### 2.1 협력 (Collaboration)

**정의**: 시스템의 목표(예: 야구 경기에서 승리하기)를 달성하기 위해 여러 객체가 함께 행동하는 것입니다.

**특징**:
- 객체는 혼자 존재하지 않고 다른 객체와 협력하여 목표를 달성
- 협력은 메시지를 통해 이루어짐
- 각 객체는 자신의 책임을 수행하면서 협력에 참여

**예시**: 야구 경기 시스템에서 공을 던지고 타격하기까지
- 감독 → 공 던지기 요청 메시지 → 투수
- 투수 → 공 던지기 → 타자
- 타자 → 공 치기 → 외야수
- 외야수 → 공 잡기 → 포수
- 포수 → 아웃 처리 완료 메시지 → 감독

##### 2.2 책임 (Responsibility)

**정의**: 협력 속에서 각 객체가 수행해야 할 임무입니다.

**책임의 두 가지 측면**:
- **무엇을 알고 있는가 (Knowing)**: 객체가 자신의 상태를 알고 관리
- **무엇을 할 수 있는가 (Doing)**: 객체가 수행할 수 있는 행동

**예시**:
- **야구팀**: 경기 상황을 알고 있음, 경기를 관리할 수 있음
- **투수**: 투구 방법을 알고 있음, 공을 던질 수 있음
- **타자**: 타격 방법을 알고 있음, 공을 칠 수 있음
- **외야수**: 수비 위치를 알고 있음, 공을 잡을 수 있음

> [!important] 핵심 원리
> 객체는 자신의 책임만 수행하고, 다른 객체의 내부 구현을 알 필요가 없습니다. 이를 통해 결합도를 낮추고 유지보수성을 높입니다.

##### 2.3 역할 (Role)

**정의**: 동일한 목적을 가진 책임들의 묶음입니다.

**특징**:
- 하나의 역할은 여러 객체가 수행할 수 있음
- 역할을 통해 유연한 설계가 가능
- 예: '치킨을 튀기는 책임'을 가진 객체 = '요리사' 역할

**예시**:
- **투수 역할**: 공을 던지는 책임, 투구 방법을 알고 있는 책임
- **타자 역할**: 공을 치는 책임, 타격 방법을 알고 있는 책임
- **외야수 역할**: 공을 잡는 책임, 수비 위치를 알고 있는 책임

##### 2.4 메시지 (Message)

**정의**: 객체 간의 소통 방식입니다.

**특징**:
- "무엇을(What)" 할지만 요구하고, "어떻게(How)" 할지는 묻지 않음
- Java에서는 메서드 호출로 구현
- 메시지를 받은 객체는 자신의 방식으로 처리

**예시**:
```java
// 메시지: "공을 던져줘"
pitcher.throwBall();

// 메시지: "공을 쳐줘"
batter.hitBall();

// 메시지: "공을 잡아줘"
outfielder.catchBall();
```

> [!note] 메시지 vs 메서드
> - **메시지**: 객체 간의 요청 (What)
> - **메서드**: 메시지에 대한 응답 구현 (How)

##### 2.5 자율성 (Autonomy)

**정의**: 객체는 메시지를 받았을 때 그 처리 방법을 스스로 선택하는 능동적인 존재입니다.

**특징**:
- 현실의 공은 수동적이지만, 객체지향 세계의 공은 스스로 던져질 수도 있음
- 객체는 자신의 내부 구현을 숨기고 외부에는 인터페이스만 제공
- 캡슐화를 통해 자율성 보장

**예시**:
```java
// 투수는 "공을 던져줘" 메시지를 받으면
// 자신만의 방식으로 투구 (구속, 구종 등은 투수가 결정)
class Pitcher {
    public Ball throwBall() {
        // 투수만의 비밀 구종으로 투구
        return new Ball(fastballAt150kmh());
    }
}
```

##### 2.6 다형성 (Polymorphism)

**정의**: 서로 다른 객체가 동일한 메시지에 대해 각자의 방식으로 반응할 수 있는 능력입니다.

**특징**:
- 동일한 인터페이스를 통해 다양한 구현 사용 가능
- 유연한 교체가 가능
- 런타임에 실제 객체의 메서드가 호출됨

**예시**:
```java
// 동일한 메시지 "공을 던져줘"
Pitcher fastballPitcher = new FastballPitcher();
Pitcher curveballPitcher = new CurveballPitcher();

fastballPitcher.throwBall();  // 직구로 투구
curveballPitcher.throwBall(); // 커브로 투구
```

**다형성의 장점**:
- 코드의 유연성 향상
- 확장성 향상 (새로운 투수 타입 추가 용이)
- 결합도 감소

#### 3. 설계 비교: 데이터 중심 vs 책임 주도

'야구팀'을 코드로 구현하는 두 가지 방식을 비교하여 올바른 설계법을 제시합니다.

##### 3.1 데이터 중심 설계 (나쁜 예)

**접근 방식**: "이 객체가 무엇을 가지고 있어야 하는가?"에 집중합니다.

**예시**: 야구팀은 투수, 타자, 포수를 가져야 해

```java
// 데이터 중심 설계
class BaseballTeam {
    private Pitcher pitcher;           // 투수를 가지고 있음
    private Batter batter;             // 타자를 가지고 있음
    private Catcher catcher;          // 포수를 가지고 있음
    
    public void playGame() {
        pitcher.throwBall();          // 투수 사용
        batter.hitBall();             // 타자 사용
        catcher.catchBall();          // 포수 사용
    }
}
```

**문제점**:
- ❌ 객체끼리 서로 너무 많이 알게 되어 **결합도(Coupling)**가 높아집니다
- ❌ 하나를 수정하면 관련된 모든 코드를 수정해야 합니다
- ❌ 투수가 바뀌면 야구팀 코드도 수정 필요
- ❌ 타자가 없어지면 야구팀이 작동하지 않음
- ❌ 테스트하기 어려움 (의존성이 많음)

**결합도가 높은 경우**:
```java
// 투수 클래스 변경 시 야구팀도 수정 필요
class Pitcher {
    public void throwWithNewMethod() { ... } // 메서드 이름 변경
}

// 야구팀도 수정해야 함
class BaseballTeam {
    public void playGame() {
        pitcher.throwWithNewMethod(); // 변경된 메서드 호출
    }
}
```

##### 3.2 책임 주도 설계 (좋은 예)

**접근 방식**: "이 객체가 어떤 책임을 수행해야 하는가?"에 집중합니다.

**설계 과정**:
1. 시스템의 책임을 파악
2. 더 작은 책임으로 나누기
3. 적절한 객체에게 할당

**예시**: 
- 야구팀(경기 관리 책임) 
- 투수(공 던지기 책임) 
- 타자(타격하기 책임)
- 외야수(수비하기 책임)

```java
// 책임 주도 설계
class BaseballTeam {
    // 야구팀의 책임: 경기를 관리하는 것
    public void playGame() {
        // 투구 책임을 투수에게 위임
        Ball ball = requestPitching();
        
        // 타격 책임을 타자에게 위임
        HitResult result = requestHitting(ball);
        
        // 수비 책임을 외야수에게 위임
        requestDefense(result);
    }
    
    private Ball requestPitching() {
        // 어떻게 투구하는지는 투수가 결정
        return pitcher.throwBall();
    }
    
    private HitResult requestHitting(Ball ball) {
        // 어떻게 타격하는지는 타자가 결정
        return batter.hit(ball);
    }
    
    private void requestDefense(HitResult result) {
        // 어떻게 수비하는지는 외야수가 결정
        outfielder.catchBall(result);
    }
}
```

**장점**:
- ✅ 책임이 깔끔하게 분리되어 유지보수가 쉬워집니다
- ✅ 결합도가 낮아져 변경에 유연합니다
- ✅ 각 객체가 자신의 책임만 수행
- ✅ 테스트하기 쉬움 (각 객체를 독립적으로 테스트 가능)
- ✅ 확장성이 높음 (새로운 투수나 타자 추가 용이)

**결합도가 낮은 경우**:
```java
// 투수 인터페이스 (역할 정의)
interface Pitcher {
    Ball throwBall();
}

// 직구 투수
class FastballPitcher implements Pitcher {
    public Ball throwBall() { ... }
}

// 커브 투수
class CurveballPitcher implements Pitcher {
    public Ball throwBall() { ... }
}

// 야구팀은 투수의 구체적인 타입을 몰라도 됨
class BaseballTeam {
    private Pitcher pitcher; // 인터페이스에 의존
    
    public void playGame() {
        Ball ball = pitcher.throwBall(); // 다형성 활용
    }
}
```

#### 4. 객체지향적인 야구팀 설계 (예제 실습)

**설계 단계**:

1. **시스템 목표 파악**: 야구 경기에서 승리하기

2. **책임 식별**:
   - 경기 관리하기
   - 공 던지기
   - 타격하기
   - 수비하기

3. **객체 할당**:
   - `BaseballTeam`: 경기 관리 책임
   - `Pitcher`: 공 던지기 책임
   - `Batter`: 타격하기 책임
   - `Outfielder`: 수비하기 책임

4. **협력 설계**:
   ```
   Coach → (경기 시작) → BaseballTeam
   BaseballTeam → (투구 요청) → Pitcher
   Pitcher → (공 던지기) → Batter
   Batter → (타격) → Outfielder
   Outfielder → (수비 완료) → BaseballTeam
   BaseballTeam → (경기 결과) → Coach
   ```

**구현 예시**:
```java
// 역할 인터페이스
interface Pitcher {
    Ball throwBall();
}

interface Batter {
    HitResult hit(Ball ball);
}

interface Outfielder {
    void catchBall(HitResult result);
}

// 구체적인 객체
class FastballPitcher implements Pitcher {
    public Ball throwBall() {
        // 투수만의 방식으로 직구 투구
        return new Ball(150, "fastball");
    }
}

class PowerBatter implements Batter {
    public HitResult hit(Ball ball) {
        // 타자만의 방식으로 강타
        return new HitResult("home run");
    }
}

class CenterFielder implements Outfielder {
    public void catchBall(HitResult result) {
        // 외야수만의 방식으로 수비
        System.out.println("아웃!");
    }
}

// 야구팀 (협력의 중심)
class BaseballTeam {
    private Pitcher pitcher;
    private Batter batter;
    private Outfielder outfielder;
    
    public void playInning() {
        // 1. 투구 책임 위임
        Ball ball = pitcher.throwBall();
        
        // 2. 타격 책임 위임
        HitResult result = batter.hit(ball);
        
        // 3. 수비 책임 위임
        outfielder.catchBall(result);
    }
}
```

#### 5. 정리 및 결론

**핵심 요약**:

1. **객체지향 프로그래밍의 정의**:
   - 현실 세계를 추상화하여 직관적으로 이해하기 쉽고 변경을 용이하게 만드는 개발 방법론
   - 소설이 현실을 기반으로 쓰이듯, 객체지향 코드도 현실의 개념을 기반으로 작성

2. **핵심 키워드**:
   - **협력**: 여러 객체가 함께 목표를 달성
   - **책임**: 객체가 수행해야 할 임무 (무엇을 알고 있는가 + 무엇을 할 수 있는가)
   - **역할**: 동일한 목적을 가진 책임들의 묶음
   - **메시지**: 객체 간의 소통 방식 (What만 요구, How는 묻지 않음)
   - **자율성**: 객체가 메시지 처리 방법을 스스로 선택
   - **다형성**: 동일한 메시지에 대해 각자의 방식으로 반응

3. **설계 방법**:
   - **데이터 중심 설계**: "무엇을 가지고 있는가?"에 집중 → 결합도 높음, 유지보수 어려움
   - **책임 주도 설계**: "어떤 책임을 수행하는가?"에 집중 → 결합도 낮음, 유지보수 용이

**개인적 인사이트**:
- 객체지향은 단순한 프로그래밍 기법이 아니라 시스템을 설계하는 철학입니다.
- 책임 주도 설계를 통해 결합도를 낮추고 응집도를 높이면 유지보수 가능한 코드를 작성할 수 있습니다.
- 협력, 책임, 역할을 명확히 정의하면 확장 가능한 시스템을 설계할 수 있습니다.

**추가 학습 제안**:
- CRC 카드(Class-Responsibility-Collaborator) 활용
- SOLID 원칙
- 디자인 패턴
- 리팩토링 기법

---

### 설정 시 반드시 고려해야 할 파라미터

- **책임 분리**: 
  - 각 객체가 단일 책임만 가지도록 설계
  - 하나의 객체가 너무 많은 책임을 가지지 않도록 주의

- **결합도와 응집도**: 
  - 결합도는 낮게, 응집도는 높게
  - 인터페이스를 통한 의존성 관리

- **다형성 활용**: 
  - 역할(인터페이스)에 의존하고 구현(클래스)에 의존하지 않기
  - 상속보다는 인터페이스 활용

- **메시지 설계**: 
  - "무엇을" 할지만 요구하고 "어떻게" 할지는 묻지 않기
  - 객체의 내부 구현을 숨기기

#### 흔히 발생하는 문제/오해

> [!warning] 흔한 오해
> 
> 1. **"객체지향은 클래스를 많이 만들면 되는 것"**: 
>    - 단순히 클래스를 많이 만드는 것이 아니라, 적절한 책임 분리가 중요합니다.
> 
> 2. **"Getter/Setter를 만들면 캡슐화가 되는 것"**: 
>    - Getter/Setter를 무분별하게 만들면 오히려 캡슐화를 깨뜨릴 수 있습니다.
> 
> 3. **"상속을 많이 사용하면 좋은 설계"**: 
>    - 상속은 강한 결합을 만들 수 있으므로, 인터페이스를 통한 다형성이 더 유연합니다.
> 
> 4. **"데이터 중심 설계가 더 직관적"**: 
>    - 데이터 중심 설계는 결합도를 높여 유지보수를 어렵게 만듭니다.

#### 객체지향 모르면 발생하는 문제점

> [!error] 이걸 모르고 사용하면
> 
> - **높은 결합도**: 객체 간 의존성이 높아 하나를 수정하면 여러 곳을 수정해야 함
> - **낮은 재사용성**: 코드를 재사용하기 어려워 중복 코드 발생
> - **유지보수 어려움**: 변경 사항이 발생하면 관련된 모든 코드를 수정해야 함
> - **테스트 어려움**: 객체 간 강한 결합으로 인해 단위 테스트 작성 어려움
> - **확장성 부족**: 새로운 기능 추가 시 기존 코드를 많이 수정해야 함
> - **코드 가독성 저하**: 책임이 명확하지 않아 코드 이해가 어려움

---

### 예상 꼬리질문 정리

#### 1. 객체지향의 4대 특징은?

- **캡슐화 (Encapsulation)**: 데이터와 메서드를 하나로 묶고, 외부에서 직접 접근하지 못하도록 함
- **상속 (Inheritance)**: 기존 클래스의 속성과 메서드를 재사용
- **다형성 (Polymorphism)**: 동일한 인터페이스로 다양한 구현 사용
- **추상화 (Abstraction)**: 복잡한 것을 단순하게 표현

#### 2. 캡슐화와 정보 은닉의 차이는?

- **캡슐화**: 데이터와 메서드를 하나로 묶는 것
- **정보 은닉**: 객체의 내부 구현을 숨기는 것 (캡슐화의 한 방법)
- 캡슐화를 통해 정보 은닉을 달성

#### 3. 상속과 컴포지션의 차이는?

- **상속 (is-a 관계)**: 
  - "A는 B이다" 관계
  - 강한 결합, 부모 클래스 변경 시 영향
  - 예: `FastballPitcher extends Pitcher`
  
- **컴포지션 (has-a 관계)**: 
  - "A는 B를 가지고 있다" 관계
  - 느슨한 결합, 유연한 설계
  - 예: `BaseballTeam has Pitcher`

#### 4. 인터페이스와 추상 클래스의 차이는?

- **인터페이스**: 
  - 다중 상속 가능
  - 구현 없이 메서드 시그니처만 정의
  - 역할을 정의할 때 사용
  
- **추상 클래스**: 
  - 단일 상속만 가능
  - 일부 구현 포함 가능
  - 공통 기능을 정의할 때 사용

#### 5. 결합도와 응집도의 차이는?

- **결합도 (Coupling)**: 
  - 모듈 간의 의존성 정도
  - 낮을수록 좋음 (독립적)
  
- **응집도 (Cohesion)**: 
  - 모듈 내부 요소 간의 관련성
  - 높을수록 좋음 (밀접한 관련)

#### 6. SOLID 원칙이란?

- **S (Single Responsibility)**: 단일 책임 원칙
- **O (Open-Closed)**: 개방-폐쇄 원칙
- **L (Liskov Substitution)**: 리스코프 치환 원칙
- **I (Interface Segregation)**: 인터페이스 분리 원칙
- **D (Dependency Inversion)**: 의존성 역전 원칙

#### 7. CRC 카드란?

- **Class-Responsibility-Collaborator**: 클래스, 책임, 협력자를 카드로 정리
- 객체지향 설계를 위한 도구
- 각 객체의 책임과 협력 관계를 명확히 정의

---

## 관련 노트

- **[[클래스]]** - 객체를 생성하기 위한 템플릿
- **[[객체]]** - 클래스의 인스턴스
- **[[상속]]** - 기존 클래스의 재사용
- **[[다형성]]** - 동일한 인터페이스로 다양한 구현
- **[[캡슐화]]** - 데이터와 메서드를 묶기
- **[[추상화]]** - 복잡한 것을 단순하게 표현
- **[[인터페이스]]** - 역할을 정의하는 계약
- **[[SOLID 원칙]]** - 객체지향 설계 원칙

---

> [!tip] 다음 단계
> 객체지향 프로그래밍을 이해했다면, **[[SOLID 원칙]]**과 **[[디자인 패턴]]**을 학습하여 더 나은 설계를 할 수 있습니다.

---

**태그:** #java #oop #객체지향 #설계 #면접 #개념정리

