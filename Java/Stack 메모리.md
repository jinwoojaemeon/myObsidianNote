# Stack 메모리

#java #stack #memory #jvm #면접 #개념정리

**관련 개념:** [[Heap 메모리]] [[JVM (Java Virtual Machine, 자바 가상 머신)|JVM]] [[Runtime Data Area]] [[가비지 컬렉션 (Garbage Collection)|가비지 컬렉션]]

> [!note] 관련 개념
> Stack 메모리는 **[[Heap 메모리]]**와 함께 JVM의 Runtime Data Area를 구성합니다. Stack은 메서드 실행에 필요한 데이터를 저장하고, Heap은 객체 인스턴스를 저장합니다.

---

## Topic (오늘의 주제)

Java의 Stack 메모리가 무엇인지, 어떤 데이터를 저장하는지, 그리고 왜 가비지 컬렉션이 필요 없는지 이해한다.

---

### **Why (왜 사용하는가? 왜 중요한가?)**

- **실무**: Stack 메모리가 없으면 메서드 호출 시 지역 변수, 매개변수, 반환 주소 등을 저장할 수 없습니다. 메서드 실행 컨텍스트를 관리할 수 없어 프로그램 실행이 불가능하며, 스레드별로 독립적인 실행 공간이 없어 멀티스레드 프로그래밍이 불가능합니다.

- **구조적 의미**: Stack은 LIFO(Last In First Out) 구조로 메서드 호출과 반환을 효율적으로 관리합니다. 스레드별로 독립적인 Stack을 제공하여 멀티스레드 환경에서 안전한 실행을 보장하며, 메서드 종료 시 자동으로 정리되어 메모리 관리 오버헤드가 없습니다.

- **면접 의도**: JVM의 메모리 구조에 대한 이해, Stack과 Heap의 차이, 왜 Stack은 GC가 필요 없는지, 그리고 메서드 호출 시 메모리 동작 방식을 확인하려 합니다.

---

### **Core Concept (핵심 개념 정리)**

#### 개념 정의

**Stack 메모리**는 각 스레드마다 독립적으로 할당되는 메모리 영역으로, 메서드 호출 시 생성되는 메서드 프레임(Stack Frame)을 저장합니다. LIFO 구조로 동작하며, 메서드 종료 시 자동으로 해제됩니다.

#### 동작 방식

```
메서드 호출 시 Stack 동작:

1. 메서드 호출
   methodA() 호출
      ↓
2. Stack Frame 생성
   - 지역 변수 저장 공간 할당
   - 매개변수 저장
   - 반환 주소 저장
      ↓
3. 메서드 실행
   - 지역 변수 사용
   - 다른 메서드 호출 시 새로운 Frame 생성 (Stack에 push)
      ↓
4. 메서드 종료
   - Stack Frame 제거 (Stack에서 pop)
   - 메모리 자동 해제
```

**Stack Frame 구조**:
- **지역 변수 배열**: 메서드 내 지역 변수 저장
- **피연산자 스택**: 연산에 사용되는 임시 값 저장
- **프레임 데이터**: 반환 주소, 예외 처리 정보 등

#### 저장되는 데이터

**Stack에 저장되는 것**:
- 기본 타입 변수 (int, double, boolean 등)
- 객체 참조 변수 (객체의 주소만 저장)
- 메서드 매개변수
- 메서드 프레임 (반환 주소, 예외 처리 정보)

**Stack에 저장되지 않는 것**:
- 객체 인스턴스 (Heap에 저장)
- 배열의 실제 데이터 (Heap에 저장)
- 클래스 정보 (Method Area에 저장)

#### Stack vs Heap 비교

| 구분 | Stack | Heap |
|:---:|:---:|:---:|
| **저장 대상** | 기본 타입, 참조 변수 | 객체 인스턴스 |
| **할당 시점** | 메서드 호출 시 | `new` 키워드 사용 시 |
| **해제 시점** | 메서드 종료 시 자동 | GC가 회수할 때 |
| **생명주기** | 명확 (메서드 스코프) | 불명확 (참조 관계) |
| **스레드** | 스레드별 독립 | 모든 스레드 공유 |
| **크기** | 제한적 (보통 1MB) | 크게 설정 가능 |
| **속도** | 빠름 (순차 할당) | 상대적으로 느림 |
| **GC 필요** | ❌ 불필요 (자동 해제) | ✅ 필요 |

#### 장점/단점

**장점**:
- 메서드 종료 시 자동 해제로 메모리 관리 오버헤드 없음
- 빠른 할당/해제 (순차적 메모리 관리)
- 스레드별 독립성으로 멀티스레드 안전성 보장
- GC가 필요 없어 성능 오버헤드 없음

**단점**:
- 크기가 제한적 (보통 1MB, 설정 가능)
- Stack Overflow 발생 가능 (재귀 호출 시)
- 객체는 저장할 수 없고 참조만 저장 가능

#### 필요 조건

- **JVM 실행**: Stack은 JVM이 스레드 생성 시 자동 할당
- **스레드**: 각 스레드마다 독립적인 Stack 할당
- **크기 설정**: `-Xss` 옵션으로 Stack 크기 설정 가능 (예: `-Xss1m`)

---

### **Interview Answer Version (면접 답변식 요약)**

Stack 메모리는 각 스레드마다 독립적으로 할당되는 메모리 영역으로, 메서드 호출 시 생성되는 메서드 프레임을 저장합니다.

사용하는 이유는 메서드 실행에 필요한 지역 변수, 매개변수, 반환 주소 등을 저장하기 위해서입니다. LIFO 구조로 동작하여 메서드 호출과 반환을 효율적으로 관리하며, 스레드별로 독립적인 Stack을 제공하여 멀티스레드 환경에서 안전한 실행을 보장합니다.

핵심 특징은 메서드 종료 시 자동으로 해제된다는 점입니다. 생명주기가 명확하여 가비지 컬렉션이 필요 없으며, 이는 **[[Heap 메모리]]**와의 가장 큰 차이점입니다.

---

### **Practical Tip (사용시 주의할 점 or 활용 예)**

#### 설정 시 반드시 고려해야 할 파라미터

- **Stack 크기 설정**: `-Xss1m` (기본값은 OS와 JVM 버전에 따라 다름)
- **재귀 호출**: 깊은 재귀 호출 시 Stack Overflow 발생 가능
- **스레드 수**: 스레드마다 Stack이 할당되므로 스레드 수 × Stack 크기만큼 메모리 사용

#### 흔히 발생하는 문제/오해

> [!warning] 흔한 오해
> 
> "Stack에 객체를 저장할 수 있다"는 생각은 잘못되었습니다. Stack에는 객체 인스턴스가 아닌 참조(주소)만 저장됩니다. 실제 객체는 **[[Heap 메모리]]**에 저장되며, Stack의 참조 변수가 Heap의 객체를 가리킵니다.

#### 적용 사례

```java
public void example() {
    int num = 10;              // Stack: 기본 타입 변수
    String str = "Hello";       // Stack: 참조 변수 (String 객체는 Heap)
    Object obj = new Object();  // Stack: 참조 변수, Heap: Object 인스턴스
    
    // 메서드 종료 시 Stack의 변수들은 자동 해제
    // Heap의 객체는 GC가 회수할 때까지 남아있음
}
```

#### 이걸 모르고 사용하면 생기는 문제

> [!error] 이걸 모르고 사용하면
> 
> - **StackOverflowError**: 재귀 호출이 너무 깊거나 무한 루프 발생
> - **메모리 낭비**: Stack 크기를 과도하게 크게 설정
> - **객체 저장 오해**: Stack에 객체를 저장하려고 시도하는 실수
> - **스레드 수 증가**: 많은 스레드 생성 시 Stack 메모리 부족

---

### 예상 꼬리질문정리

#### 1. 왜 Stack은 가비지 컬렉션이 필요 없나?

- **생명주기가 명확함**: 메서드 호출 시 생성되고 종료 시 자동 해제
- **LIFO 구조**: 마지막에 들어온 것이 먼저 나가는 구조로 자동 정리
- **스레드별 독립**: 각 스레드가 자신의 Stack을 관리하므로 복잡한 참조 관계 없음
- **결론**: **[[가비지 컬렉션 (Garbage Collection)|GC]]**는 생명주기가 불명확한 **[[Heap 메모리]]**에서만 필요

#### 2. Stack에 객체를 저장할 수 있나?

- **아니요**: Stack에는 객체 인스턴스를 저장할 수 없음
- **참조만 저장**: 객체의 주소(참조)만 Stack에 저장
- **실제 객체**: **[[Heap 메모리]]**에 저장됨
- **관계**: Stack의 참조 변수 → Heap의 객체 인스턴스

#### 3. Stack Overflow는 언제 발생하나?

- **재귀 호출이 너무 깊을 때**: 각 재귀 호출마다 Stack Frame이 생성됨
- **무한 재귀**: 종료 조건이 없는 재귀 함수
- **해결 방법**: 
  - 재귀 대신 반복문 사용
  - Stack 크기 증가 (`-Xss` 옵션)
  - 꼬리 재귀 최적화 (일부 JVM에서 지원)

#### 4. Stack 크기를 어떻게 설정하나?

- **기본값**: OS와 JVM 버전에 따라 다름 (보통 1MB)
- **설정 방법**: `-Xss1m` (1MB로 설정)
- **주의**: 
  - 너무 크면 메모리 낭비
  - 너무 작으면 Stack Overflow 발생 가능
  - 스레드 수 × Stack 크기만큼 메모리 사용

#### 5. Stack과 Heap의 관계는?

- **Stack의 참조 변수**: Heap의 객체를 가리킴
- **메서드 종료 시**: Stack은 자동 해제, Heap의 객체는 GC가 회수
- **예시**:
  ```java
  Object obj = new Object();
  // Stack(obj) → Heap(Object 인스턴스)
  // 메서드 종료: Stack의 obj는 사라지지만, Heap의 Object는 GC가 회수할 때까지 남음
  ```

---

## 관련 노트

- **[[Heap 메모리]]** - 객체 인스턴스가 저장되는 메모리 영역 (이어서 읽기 권장)
- **[[JVM (Java Virtual Machine, 자바 가상 머신)|JVM]]** - Stack이 속한 JVM 환경
- **[[Runtime Data Area]]** - Stack과 Heap의 메모리 구조
- **[[가비지 컬렉션 (Garbage Collection)|가비지 컬렉션]]** - Heap 메모리 관리 메커니즘

---

> [!tip] 다음 단계
> Stack 메모리를 이해했다면 **[[Heap 메모리]]**를 함께 학습하여 JVM의 메모리 구조를 완전히 이해하세요. Stack과 Heap의 관계와 차이점을 파악하면 메모리 관리와 **[[가비지 컬렉션 (Garbage Collection)|GC]]**를 더 잘 이해할 수 있습니다.

---

**태그:** #java #stack #memory #jvm #면접 #개념정리

